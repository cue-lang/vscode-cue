package extension

import (
	"encoding/json"
	"list"
	"path"
	"strings"

	"tool/cli"
	"tool/exec"
	"tool/file"
)

_os: string @tag(os, var=os)

// genManifest writes out a manifest.txt file that captures the contents
// of the extension. This command should be run after vsce package.
command: genManifest: {
	ls: exec.Run & {
		cmd: ["vsce", "ls"]
		stdout: string
	}

	redirect: file.Create & {
		// Somewhat incredibly, the output from 'vsce ls' does not appear to be stable.
		let trimmed = strings.TrimSpace(ls.stdout)
		let lines = strings.Split(trimmed, "\n")
		let orderedLines = list.SortStrings(lines)
		let ordered = strings.Join(orderedLines, "\n")
		filename: "manifest.txt"
		contents: """
		# Code generated by cue cmd genManifest; DO NOT EDIT.

		\(ordered)

		"""
	}
}

// genPackageJSON generates an npm package.json file from the current site configuration.
command: genPackageJSON: write: file.Create & {
	filename: "package.json"

	// json.Indent does not produce a trailing newline. Hence we include one
	// "manually" here.
	contents: """
		\(json.Indent(json.Marshal(extension.npm), "", "  "))

		"""
}

// writebackPackageJSON ensures that the npm.cue file (which belongs to the
// site package) contains the npm-controlled parts of package.json
command: writebackPackageJSON: {
	// extract the relevant config value
	extract: exec.Run & {
		cmd: ["cue", "export", "--out=json", "-e=devDependencies", "package.json"]
		stdout: string
	}
	// place at a path: extension.npm
	place: exec.Run & {
		cmd: ["cue", "export", "--out=cue", "-l=extension:", "-l=npm:", "-l=devDependencies:", "-p=extension", "json:", "-"]
		stdin:  extract.stdout
		stdout: string
	}
	// write to the npm.cue file
	write: file.Create & {
		filename: "npm.cue"
		contents: place.stdout
	}
}

// checkReleaseVersion ensures that the extension-configured version (which is
// not actually a true semver version) corresponds to the string "argument"
// passed via the attribute named tag are equal. We use a rather unpleasant
// hack to force a failure because cue cmd has no such primitive.
command: checkReleaseVersion: {
	_version: string @tag(tag)

	let commitVersion = "v" + extension.npm.version

	if commitVersion != _version {
		msg: cli.Print & {
			text: "commitVersion \(commitVersion) != tag version \(_version)"
		}
		error: exec.Run & {
			$after: msg
			cmd:    "false"
		}
	}
}

command: genTS: file.Create & {
	filename: path.FromSlash("src/gen_userCommands.ts", _os)

	contents: """
		// Copyright 2024 The CUE Authors
		//
		// Licensed under the Apache License, Version 2.0 (the "License");
		// you may not use this file except in compliance with the License.
		// You may obtain a copy of the License at
		//
		//     http://www.apache.org/licenses/LICENSE-2.0
		//
		// Unless required by applicable law or agreed to in writing, software
		// distributed under the License is distributed on an "AS IS" BASIS,
		// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		// See the License for the specific language governing permissions and
		// limitations under the License.

		let _config = \(json.Marshal(extension));
		export const config: Readonly<typeof _config> = Object.freeze(_config);

		"""
}
